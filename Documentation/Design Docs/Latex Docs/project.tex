% !TEX root = DesignDocument.tex


\chapter{Project Management}

\section{Team Member's Roles}
Kendra Deziel was in charge of GUI design, implementation, and debugging. All members of the team created wireframe ideas which she concatenated with the intention of keeping to the generic video game interface standards most users will know and understand.
Andrew Stelter was in charge of backend design, implementation, and debugging. This included things like file loading, unit tests, and the design of interfaces between all modules of the project. He was also the scrum master and architect of the project layers.
Ryley Sutton was in charge of the world view design, implementation, and debugging. This is the section in the center of the project where the simulation, map, and robot can be viewed. She selected Qt graphics framework which supports interaction between 2D objects as well as allows for easy rotating. This was chosen over OpenGL because it was readily available, developed to be used in Qt by Qt easily and most importantly was better documented for use with Qt for easier learning.  
Samuel Williams was in charge of the physics design, implementation, and debugging. He selected Box 2D as the physics engine for the project to handle movements and collisions of all world view objects: robot or map object.

Specific details on why eah of these design decisions were made are available at the beginning of the Design and Implementation section of this document (Section 4).


\section{Project  Management Approach}
For this project, an adapted agile approach was taken. Our sprints were two weeks long, which we judged to be the best length based on our schedules as students and on the complexity of the project overall. Team meetings were scheduled once weekly, sometimes with bonus 'coding sessions', and client meetings were also scheduled once weekly. 

Trello was used to keep track of backlog items, which were derived from user stories during group meetings. Git was used for our repository.

Communications between group members happened almost exclusively over text and email, or in person.

Backlog items were assigned to specific group members during group meetings after being assigned an adequately high priority.


\section{ Stakeholder Information}
This project's successful completion would not only be a positive occurence for our clients, it could also come to benefit future robotics classes, not only at the South Dakota School of Mines and Technology, but the nation or maybe even the world over.

Anybody currently using a worse alternative for 2D robotics simulation would likely be happy to hear of the successful completion of this project.

\subsection{Customer or End User (Product Owner)}
Dr. Jeff McGough and Christopher Smith are our clients or 'customers'. Their input generates user stories and helps to determine the priority of backlog items at weekly meetings, where they deliver this input to the entire development team in a progress report style dialogue.

\subsection{Developers --Testers}
Andrew Stelter is acting as our lead developer and project manager. Samuel Williams is a developer primarily focused on the physics engine and backend. Kendra Deziel is a developer primarily focused on our GUI. Ryley Sutton is a devloper primarily focused on graphics.

\section{Intellectual Property and Licensing}
This project is going to open source on GitHub. We have yet to select a license. 

\section{Sprint  Overview}
At the beginning of each sprint, a group meeting is used to reevaluate our backlog. This consists of moving items that have been completed to a board specifically for completed items, adding new backlog items generated from user stories, reevaluating the priority of items that are not in progress, and assigning those items of highest priority to specific team members, or in some cases, groups of team members to be completed in a timely manner.

Over the course of the next week, individual work is done by each group member on the items assigned to them with collaboration in the case that one team member needs help from another.

A client meeting occurs, a progress report is given, new user stories are collected, and another group meeting happens to discuss progress amongst ourselves, and to assign additional work in the case that someone has already finished their work for the sprint.

Over the next week, more individual work and testing takes place, there is another client meeting, and completed items are pushed to the repository. Any unfinished items are carried over into the next sprint.

\section{Terminology and Acronyms}
Provide a list of terms used in the document that warrant definition.  Consider 
industry or domain specific terms and acronyms as well as system specific. 

\subsection{ROS - Robot Operating System}
A flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms.

\subsection{STDR - Simple Two Dimensional Robot Simulator}
A simple robot simulator, and a predecessor to this project. The goal of this project from the start was to improve on the STDR, and although we decided to write our own program from scratch, the STDR has often been used for reference and comparison.

\subsection{SDSMT - South Dakota School of Mines and Technology}
The university at which this project was developed. All authors are students of SDSMT.

\section{Sprint Schedule}
\begin{center}
	\begin{tabular}{r l l}
		Sprint & Start Date & End Date \\ \hline
		Sprint 0 & Sep 7 & Sep 21 \\
		Sprint 1 & Sep 21 & Oct 5 \\
		Sprint 2 & Oct 5 & Oct 19 \\
		Sprint 3 & Oct 19 & Nov 2 \\
		Sprint 4 & Nov 2 & Nov 16 \\
		Sprint 5 & Nov 16 & Nov 30 \\
		Sprint 6 & Nov 30 & Jan 11 \\
		Sprint 7 & Jan 11 & Jan 25 \\
		Sprint 8 & Jan 25 & Feb 8 \\
		Sprint 9 & Feb 8 & Feb 22 \\
		Sprint 10 & Feb 22 & Mar 8 \\
		Sprint 11 & Mar 8 & Mar 22 \\
		Sprint 12 & Mar 22 & Apr 5 \\
		Sprint 13 & Apr 5 & Apr 19 \\
		Sprint 14 & Apr 19 & May 3 \\
	\end{tabular}
\end{center}

\section{Timeline}

\subsection{Sprint 0}
\begin{itemize}
	\item Set up team members in Ubuntu environment
	\item Decide whether or not to use STDR simulator 
 	\item Determine development tools
\end{itemize}

\subsection{Sprint 1}
\begin{itemize}
	\item Create backlog of user stories
	\item Create UI wireframes
 	\item Begin structuring architectural layers
\end{itemize}

\subsection{Sprint 2}
\begin{itemize}
	\item Create MVP
	\item Create interfaces for partition communication 
\end{itemize}

\subsection{Sprint 3}
\begin{itemize}
	\item Allow for robots spawning at non-center of map
	\item Allow for robots to rotate while moving
 	\item Be able to display and change robot properties
 	\item Find a way to pass shapes around threads
\end{itemize}

\subsection{Sprint 4}
\begin{itemize}
	\item Decide between kinematics and full-simulation physics
	\item Allow selection of robot from main view and UI menu
	\item Touch sensor plugin
 	\item Load obstacle files
\end{itemize}

\subsection{Sprint 5}
\begin{itemize}
	\item Documentation
	\item Presentation
 	\item Ethics quiz
 	\item Team evaluation
\end{itemize}

\subsection{Sprint 6}
\begin{itemize}
	\item Image loading
	\item Replace kinematics with forces for determining robot motion
 	\item Object loading and saving
 	\item Addition of LIDAR sensor
 	\item Additoin of other easy sensors
 	\item Addition of time warp feature
 	\item Addition of joystick module
 	\item Full draft of plans for Spring semester
\end{itemize}

\subsection{Sprint 7}
\begin{itemize}
	\item To be determined
\end{itemize}

\subsection{Sprint 8}
\begin{itemize}
	\item To be determined
\end{itemize}

\subsection{Sprint 9}
\begin{itemize}
	\item To be determined
\end{itemize}

\subsection{Sprint 10}
\begin{itemize}
	\item To be determined
\end{itemize}

\subsection{Sprint 11}
\begin{itemize}
	\item To be determined
\end{itemize}

\subsection{Sprint 12}
\begin{itemize}
	\item To be determined
\end{itemize}

\subsection{Sprint 13}
\begin{itemize}
	\item To be determined
\end{itemize}

\subsection{Sprint 14}
\begin{itemize}
	\item To be determined
\end{itemize}

\section{Development Environment}
As mentioned before, the target environment for this project is Ubuntu 16.04, and the target version of ROS is Kinetic Kame.

The following list of items are the bare minimum for developing this project:
\begin{itemize}
	\item Ubuntu 16.04
	\item g++ 4.8 or newer
	\item ROS Kinetic Kame
	\item Qt 5.5 headers and libraries
\end{itemize}

\subsection{Ubuntu}
An image for Ubuntu may be downloaded at \url{https://www.ubuntu.com/download/desktop}. It is not required that this image be run a specific way; this project should work whether Ubuntu is the main OS or a run in a Virtual Machine.

\subsection{Qt}
At the time of writing this document, Qt 5.5 headers and libraries are included in the Ubuntu image; this is technically all that is required (in terms of Qt) for development. If developers would prefer to have the full Qt environment installed, or these libraries and headers stop being standard, Open-Source Qt can be downloaded at \url{https://www.qt.io/download-qt-for-application-development}

\subsection{ROS Kinetic}
All development is done in a ROS Catkin build environment. Details about setting up Catkin and CMake are stated below. Information about installing ROS Kinetic on Ubuntu can be found at \url{http://wiki.ros.org/kinetic/Installation/Ubuntu}. This project was developed using the \lstinline|ros-kinetic-full-desktop| installation.


\section{Development IDE and Tools}
\subsection{Qt Creator}
No specific development IDE is required for this project; however, we chose to use Qt Creator. It should be noted that Qt Creator was not used to build and run the project, just to develop it. It is useful to use Qt Creator in this fashion because it is able to do syntax highlighting and auto-correction for some Qt-Specific code elements. The Qt Creator IDE can be installed through the open-source installer found at \url{https://www.qt.io/download-qt-for-application-development}. A number of Qt \lstinline|.pro| files exist in the project which can be used to open the project in Qt Creator. IMPORTANT: These files can not be used to build the project. See section \ref{sec:buildenv} for details on the build environment.

\subsection{\LaTeX Documentation}
This documentation was written using \LaTeX and compiles under the TexLive distribution. The tool TexMaker was used as and IDE for developing the document.
The TexLive page, which contains installation details for various OS's, can be found at \url{https://www.tug.org/texlive/}. TexMaker can be installed from \url{http://www.xm1math.net/texmaker/}. This document requires more than a minimum TexLive install; we recommend installing all available packages.

\subsection{Git Tools}
This project is managed by a Git repository. Details about the repository itself are below. Various tools exist for working with Git repositories on different OS's. At a bare minimum, the Git client is required. Information on how to install Git can be found at \url{https://git-scm.com/}. A couple of tools which were used to interface with Git during this project are Git Gui, the built-in UI(\url{https://git-scm.com/docs/git-gui}) and SourceTree, and Windows/Mac UI by Atlassian (\url{https://www.sourcetreeapp.com/}).
\section{Source  Control}
A private GitHub repository is currently being used for the source control for this project. The repository will eventually be made public, but is currently only accessible by our development team and our clients.

Branches are occasionally made for work on large features, but considerable work is also done in the master branch.

Our main files include one for documentation, one for maps, one for scripts, and several packages which are broken up into src files and include files.

\section{Dependencies}
While it is not a dependency for building and running the simulation, the Python Interpreter is highly recommended as development tool. One of the main avenues of testing the simulation is through ROS control nodes which publish control commands for robots. These nodes can be written in C++, but writing simple nodes for specific tests is generally faster in Python. A number of Python scripts are included in this project specifically for this purpose. To run them all, you will need to have installed the following in addition to ROS
\begin{itemize}
	\item Python
	\item Numpy
\end{itemize}
The included scripts were developed using Python 2 and Numpy for Python 2; however, we do not know of any reason the scripts should not work with Python 3 and Numpy for Python 3.
Before running one of these scripts, you must source ROS in your terminal.
\begin{lstlisting}
> source /opt/ros/kinetic/setup.bash
> python [script]
\end{lstlisting}

Information on installing Python and Numpy can be found at \url{https://www.python.org/} and \url{https://www.scipy.org/install.html}.

\section{Build  Environment} \label{sec:buildenv}
ROS includes a package management and build system called Catkin. Catkin is built on top of CMake, and provides some facilities for automatically linking ROS projects together.
All development for this project should be done within a Catkin Workspace. Details about how to create a workspace can be found at \url{http://wiki.ros.org/catkin/Tutorials/create_a_workspace}. 

\subsection{The Catkin Workspace}
Once a workspace is set up, the project should be cloned into \lstinline|[workspace]/src|.
Catkin and ROS provide a number of scripts which can be sourced to properly set up the build environment. In any terminal used to build this project, the script \lstinline|/opt/ros/kinetic/setup.bash| must be sourced (\lstinline|source /opt/ros/kinetic/setup.bash|). The project can then be built by running \lstinline|catkin_make| from the top directory of the workspace.

\subsection{ROS Packages}
Every package in the ROS ecosystem contains a package.xml file which provides some metadata for the package and a list of package dependencies. This allows Catkin to ensure that all package dependencies are resolved when a workspace is built. Since this project separates Box2D and the Simulator into separate packages, the line \lstinline|<depend>sdsmt_simulator_box2d</depend>| can be found in the package.xml file for the Simulator, indicating the dependency.  More information on the package.xml file can be found at \url{http://wiki.ros.org/catkin/package.xml}

\subsection{CMakeLists.txt}
Every package in the ROS ecosystem also contains a CMakeLists.txt file. This is used by CMake to correctly build, link, and deploy packages. General information about CMake can be found at \url{https://cmake.org/}.

\subsubsection*{Building Qt with CMake}
CMake provides a number of special functions specifically for building Qt projects. In a purely Qt project, the \lstinline|qmake| utility would be used to build instead of CMake or just Make. These special functions properly link Qt and include headers, process Qt-Specific macros, and convert non-C++ data files to a compile-able format. Details on these special functions can be found in the Qt Documentation at \url{http://doc.qt.io/qt-5/cmake-manual.html}

\subsubsection*{Building ROS Projects with CMake}
Catkin adds a special function \lstinline|catkin_package| which can be used in the CMakeLists.txt file. This function is used to correctly identify what portions of the package should be accessible for inclusion and linkage in other ROS packages. More details on this function can be found in the ROS documentation at \url{http://wiki.ros.org/catkin/CMakeLists.txt#catkin_package.28.29}
\subsubsection*{Box2D CMakeLists.txt Notes}
Box2D is built as a separate package from the Simulator application for a few reasons
\begin{itemize}
	\item Makes it easier to include and use in other packages (like plugins)
	\item Reduces clutter in the file tree of the simulator package
	\item Helps optimize Catkin Build process
\end{itemize}

Important things to note from the CMakeLists.txt file
\begin{itemize}
	\item It is built as a static library with C++11 and -fPIC
	\begin{lstlisting}
add_compile_options(-std=c++11 -fPIC)
	\end{lstlisting}
	\item The file tree had to be restructured slightly so that exporting the headers to other ROS packages would work correctly. The entire \lstinline|include| directory of that package is exported.

	\begin{lstlisting}
catkin_package(
  INCLUDE_DIRS include
  LIBRARIES sdsmt_simulator_box2d
)
	\end{lstlisting}
	As a result, it can be included in other packages as if it were part of that project's file tree.
	\begin{lstlisting}
#include <Box2D/Box2D.h>
	\end{lstlisting}
\end{itemize}
\subsubsection*{Simulator CMakeLists.txt Notes}
\begin{itemize}
	\item It is dependent upon the Box2D package included in this project
	\begin{lstlisting}
find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  sdsmt_simulator_box2d
)

...

catkin_package(
  INCLUDE_DIRS include
  CATKIN_DEPENDS
    roscpp
    std_msgs
    sdsmt_simulator_box2d
)
	\end{lstlisting}
	\item All headers specific to building plugins are in the directory \lstinline|include/sdsmt_simulator| so that they can be exported by Catkin according to the ROS standard.
	\item It is built with C++11
	\begin{lstlisting}
add_compile_options(-std=c++11)
	\end{lstlisting}
	\item Source files are split into four categories
	\begin{enumerate}
		\item MOC\_HDRS are header files which the Qt MOC must be run on to generate C++ source
		\item UI\_FILES are Qt .ui forms files which need to be wrapped in C++
		\item CPP\_SRCS are all the .cpp files in the project
		\item RCC\_FILES are Qt resource .qrc files that also need to be wrapped in C++
	\end{enumerate}
	\begin{lstlisting}
## Files that have any Qt macros or keywords in them
## Q_OBJECT, Q_PROPERTY, signals, slots.... etc.
set(MOC_HDRS
    include/sdsmt_simulator/drivetrain_if.h
    ...
    include/interfaces/simulator_physics_if.h
    ...
    include/basic_physics.h
    ...
    )

## .ui qt widgets form files
set(UI_FILES
    ui/mainwindow.ui
    ...
    )

## Any other source files
set(CPP_SRCS
    src/basic_maploader.cpp
    ...
    )

set(RCC_FILES ui/resources.qrc)

...

## Run MOC on files with Qt Keywords and Macros
qt5_wrap_cpp(MOC_SRCS ${MOC_HDRS})

## Wrap .ui files as cpp files
qt5_wrap_ui(UI_SRCS ${UI_FILES})

## Wrap .qrc files as cpp files
qt5_add_resources(RCC_SRCS ${RCC_FILES})
	\end{lstlisting}
	\item It is dependent on a number of Qt Modules
	\begin{lstlisting}
find_package(Qt5 REQUIRED COMPONENTS
  Core
  Widgets
  Gui
)

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)

include_directories( ${CMAKE_BINARY_DIR} )

...

add_executable(sdsmt_simulator ${UI_SRCS} ${CPP_SRCS} ${MOC_SRCS} ${RCC_SRCS})
qt5_use_modules(sdsmt_simulator Core Gui Widgets)
	\end{lstlisting}
\end{itemize}

\section{Development Machine Setup}
The recommended machine setup steps are as follows:
\begin{enumerate}
	\item Download Ubuntu 16.04
	\item Install Ubuntu 16.04 as a native OS or Virtual Machine
	\item Start Ubuntu 16.04
	\item Ensure g++ 4.8 or later is installed
	\item Install ROS Kinetic
	\item Install the Qt 5.5 Dev kit and Qt Creator
	\item Install Git
	\item Create a Catkin Workspace
	\item Clone the project repository into \lstinline|[workspace]/src|
	\item Run \lstinline|catkin_make| from the top workspace directory
\end{enumerate}
At this point, if the project builds, your system is set up for development.

Optional Steps
\begin{enumerate}
	\item Verify Python 2 is installed
	\item Install Numpy for Python 2
	\item Install the full TexLive distribution
	\item Install TexMaker
	\item Install a Git client UI
\end{enumerate}
