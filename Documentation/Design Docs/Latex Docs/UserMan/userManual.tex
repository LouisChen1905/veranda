%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}
\usepackage{makecell}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}





\title{RoboScience Simulator User Documentation}
\date{Apr 25, 2018}
\release{1.0}
\author{Ryley Sutton, Samuel Williams, Kendra Deziel, Andrew Stelter}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{index:roboscience-simulator}}\label{\detokenize{index:overview}}
The RoboScience Simulator is a learning and teaching tool for robotics. It is capable
of building a variety of different robot configurations. The robots are entirely customizable, allowing
wheels, sensors, etc to be placed wherever and however the user desires. It runs
using ROS2, and thus code run on the simulator should drive a similar real robot
in the same manner.


\chapter{Installation}
\label{\detokenize{index:installation}}
The RoboScience simulator currently is only available in its source form (it must be built
from source to be used). Also, since the simulator is a part of the ROS2 ecosystem, ROS2
must be installed and set up first. Instructions for setting up ROS2 can be found here:
\sphinxurl{https://github.com/ros2/ros2/wiki/Installation}. ROS2 can be either built from source or installed from pre-built binaries.
For the purposes of the RoboScience simulator, it does not matter which option you pick; however, if you choose
to install the pre-built binaries, you must install the following extra dependencies by
following their respective instructions under the section for building ROS2 from source.
Be sure to follow instructions for modifying the PATH when they are given.

\sphinxstylestrong{Extra Dependencies}
\begin{itemize}
\item {} 
Qt 5.10+

\item {} \begin{description}
\item[{\sphinxstylestrong{On Windows}}] \leavevmode\begin{itemize}
\item {} 
Cmake

\item {} 
pyparsing

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{On Mac OS}}] \leavevmode\begin{itemize}
\item {} 
Unfinished

\end{itemize}

\end{description}

\end{itemize}

\sphinxstylestrong{Setup}

Once the development environment is set up, create a folder to be your ROS workspace.
Within the workspace, create a src folder. Within src, clone the
project repository.

\sphinxstylestrong{Building}

In a terminal with a build environment (Any linux terminal, a VS2015 Tools terminal on
Windows) source (call on Windows) the setup.bash/.bat file appropriate for you system in
your ROS installation folder. Now, from the workspace root, run the command ament build.
This will build the project

\sphinxstylestrong{Running}

To run the project, source/call the line\textbar{}setup.bash/.bat file in the install subfolder
of the workspace. Then, run ros2 run sdsmt\_simulator sdsmt\_simulator


\chapter{Basics}
\label{\detokenize{index:basics}}

\section{Simulator}
\label{\detokenize{index:simulator}}
%\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen,height=400\sphinxpxdimen]{{simView}.png}\hspace*{\fill}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.9\textwidth]{{simView}.png}\hspace*{\fill}}
\begin{enumerate}
\item {} 
Switch to Object Designer

\item {} 
Control robot with joystrick rather than script

\item {} 
Save simulation

\item {} 
Take Snapshot of simulator screen

\item {} 
Load simulation

\item {} 
Reset simulation

\item {} 
Speed up or slow down the simulation

\item {} 
Run the simulation

\item {} 
A list of robots active in the simulation

\item {} 
A list of properties for the selected robot

\item {} 
The simulator view, all robot and obstacle movement and interactions happen here

\item {} 
Move the selected robot

\item {} 
Rotate the selected robot

\item {} 
Add a world object (robot or obstacle) to the simulation

\item {} 
Delete a world object

\item {} 
Import a world object

\item {} 
List of world objects that can be added to the simulation

\end{enumerate}

NOTE: If you select the joystick icon, a joystick window will appear

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=125\sphinxpxdimen,height=175\sphinxpxdimen]{{joystick}.png}\hspace*{\fill}}

Use your mouse to drag the center circle up to go forward, down to reverse, left to turn
left and right to turn right. Remember, forward, reverse, left and right are in regards
to the robot’s perception.


\section{Designer}
\label{\detokenize{index:designer}}
%\noindent{\hspace*{\fill}\sphinxincludegraphics[width=800\sphinxpxdimen,height=400\sphinxpxdimen]{{DView}.png}\hspace*{\fill}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.9\textwidth]{{DView}.png}\hspace*{\fill}}
\begin{enumerate}
\item {} 
Swith to Simulation View

\item {} 
Add a new world object

\item {} 
Save a world object

\item {} 
Import a world object

\item {} 
List of robots in simulation, select to edit

\item {} 
List of selected robot properties

\item {} 
Build screen for world objects, drag and drop components onto it

\item {} 
Add a selected component from the toolbox to the screen

\item {} 
Delete a selected component

\item {} 
Import a component

\item {} 
Export world object to simulation

\item {} 
List of drag and droppable components (sensors, wheels etc.)

\end{enumerate}


\section{Image Loader}
\label{\detokenize{index:image-loader}}
If you do not wish to create an obstacle course from scratch for you robots
you can choose to load in an image by selecting the… \textless{}???\textgreater{} icon. This will bring
up a menu allowing you to toggle certain properties in order to customize how an
image is converted to a map.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen,height=350\sphinxpxdimen]{{imgLoad}.png}\hspace*{\fill}}

\chapter{Python Script Examples}
\label{\detokenize{index:python-script-examples}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import ROS2 libs}
\PYG{k+kn}{import} \PYG{n+nn}{rclpy}

\PYG{k+kn}{from} \PYG{n+nn}{rclpy.node} \PYG{k+kn}{import} \PYG{n}{Node}

\PYG{c+c1}{\PYGZsh{} Import custom timer}
\PYG{k+kn}{from} \PYG{n+nn}{sdsmt\PYGZus{}simulator.SimTimer} \PYG{k+kn}{import} \PYG{n}{SimTimer}

\PYG{c+c1}{\PYGZsh{} Start a ROS2 Node}
\PYG{n}{rclpy}\PYG{o}{.}\PYG{n}{init}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{node} \PYG{o}{=} \PYG{n}{Node}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myNode}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a custom timer}
\PYG{c+c1}{\PYGZsh{} Parameter 1: Boolean    \PYGZhy{} True if the timer should listen to timestamps from the simulator; False if it should use the OS clock}
\PYG{c+c1}{\PYGZsh{} Parameter 2: String     \PYGZhy{} ROS2 topic of the timestamp message}
\PYG{c+c1}{\PYGZsh{} Parameter 3: Rclpy.Node \PYGZhy{} The ROS2 Node to use to subscribe to messages}
\PYG{n}{simTime} \PYG{o}{=} \PYG{n}{SimTimer}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sdsmt\PYGZus{}simulator/timestamp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{node}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define a callback that prints the amount of time passed}
\PYG{k}{def} \PYG{n+nf}{cb}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{simTime}\PYG{o}{.}\PYG{n}{global\PYGZus{}time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ seconds have passed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a timer to trigger the callback every 1 seconds}
\PYG{n}{simTime}\PYG{o}{.}\PYG{n}{create\PYGZus{}timer}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{cb}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Start the node}
\PYG{n}{rclpy}\PYG{o}{.}\PYG{n}{spin}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Cleanup on exit}
\PYG{n}{node}\PYG{o}{.}\PYG{n}{destroy\PYGZus{}node}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{rclpy}\PYG{o}{.}\PYG{n}{shutdown}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Using the Timestamp message}
\label{\detokenize{index:using-the-timestamp-message}}
The simulator publishes a timestamp message containing
both the delta time for the most recent tick and the total time passed in the
simulation. This message can be used to make control code more accurate when it relies
on dead reckoning. To make using this data easier, the python SimTimer class in included
with the project. The SimTimer has two simple methods:
\begin{enumerate}
\item {} 
double global\_time() - Returns total number of seconds

\item {} 
void create\_timer(delta, callback) - Starts calling {[}callback{]} every {[}delta{]} seconds

\end{enumerate}

Depending on its initialization parameters, the SimTimer will either listen
to the simulator messages for its timestamp, in which case the global time
will be the total time reported in those messages, or use a ROS node to create
a repeating timer, in which case the global time will be seconds since epoch.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sdsmt\PYGZus{}simulator.SimTimer} \PYG{k+kn}{import} \PYG{n}{SimTimer}
\end{sphinxVerbatim}

SimTimer is constructed with three parameters
\begin{itemize}
\item {} 
useSimulatedTimed: bool - whether or not the timerstamps from the simulation. If False, the os clock will be used through a ROS node

\item {} 
simulatedTimeChannel: string - ROS topic to listen on for timestamp messages

\item {} 
rosNode: rclpy.Node - the ROS node to use for listening to messages and registering a normal timer

\end{itemize}

When listening to the timestamp messages, the SimTimer keeps a priority queue of all
callbacks. They are ordered by their next target activation times. Each time a timestamp
is recieved, it is compared to the front of the queue, and until that first item has a
higher activation time than the current time, items are dequeued, called, and queued
again with a higher activation time. Activation time is calculated by adding the
callback delta to the time that the callback should have been called in a perfect
simulation, which may differ slightly from the time that it was actually called.


\chapter{Plugins}
\label{\detokenize{index:plugins}}
One of the main advantages to the design of this project is that it can be
extended through WorldObjectComponent Plugins and FileHandler Plugins. Unfortunately,
because it is a ROS package, the project (and any such plugins) must be built with
Ament and CMake. A number of plugins have been included with the project to provide
basic functionalities, and those plugins can be used as examples of how other plugins
should be set up; however, not all plugins will follow the same patterns, so this
section will describe the existing plugins as well as some of the requirements to
build and use a plugin

\sphinxstylestrong{Shape Plugins}

Shape plugins create a solid mass of a specific shape.

\sphinxstylestrong{Rectangle Plugin}

The Rectangle Plugin creates a rectangular shape. The width and height
can be specified. The corresponding Properties can be found in the table below


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Property Name
&\sphinxstyletheadfamily 
Data Type
&\sphinxstyletheadfamily 
Description
\\
\hline
Width
&
Double
&
Width of rectangle (meters)
\\
\hline
Heigh
&
Double
&
Height of rectangle (meters)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Circle Plugin}

The Circle Plugin creates a circle shape. The radius
can be specified. The corresponding Properties can be found below


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Property Name
&\sphinxstyletheadfamily 
Data Type
&\sphinxstyletheadfamily 
Description
\\
\hline
Radius
&
Double
&
Radius of circle (meters)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Polygon Plugin}

The Polygon Plugin can be used to create a solid mass in any arbitrary shape, which could
have holes in it. It is not intended to be added to objects manually, but should be used
by other plugins to create specifically shaped masses. In the future, it may be
possible to add a polygon and modify its points, but at the time of this writing, it is
not possible. Finally, the components created by this plugin are anchored and will not
move in the physics engine. The properties available from a Polygon component are shown
in the table below. But before that there are few things that should be noted:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Property Name
&\sphinxstyletheadfamily 
Data Type
&\sphinxstyletheadfamily 
Description
\\
\hline
polygon\_count
&
Integer
&
Read only: Number of triangle produced in triangulations
\\
\hline
outer\_shape
&
List of Points
&
The points that make up the outer loop of the shape
\\
\hline
inner\_shape
&
List of Lists of Points
&
The loops of points making up the holes in the outer shape
\\
\hline
straightness
&
Integer \textgreater{} 0
&
Threshold for cross product in the simplification algorithm
\\
\hline
scale/horiz
&
Double
&
Horizantal scaling factor
\\
\hline
scale/vert
&
Double
&
Vertical scaling factor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Design Details
\begin{enumerate}
\item {} 
The Box2D polygon type does not work properly with concave polygon and has a limitation on how many points can be in a polygon. To prevent either of these limitations from being a problem, the polygon is triangulated and all of the triangles are loaded as separate shapes. The triangulation algorithm is provided by the OpenGL GLU Tesselator.

\item {} 
Polygons are simplified according to the straightness property setting. This simplification algorithm is called with the straightness value as its cross product threshold.

\item {} 
Triangulation is performed each time the straightness property or one of the scaling properties changes.

\end{enumerate}

\sphinxstylestrong{Drive Plugins}

Driving plugins produce force to propel a world object. Perhaps they would be better
named ‘propulsion plugins’, but they usually emulate wheel-like hardware, so we’re
calling them driving plugins. Box2D does not actually simulate rolling of wheels in
a top-down environment, so it is all done virtually. Given the size of a wheel and its
angular velocity, we can calculate its linear velocity, and apply that velocity.
Similarly, given its linear velocity, we can calculate the portions of that velocity
in invalid directions and negate it (for example, to prevent a wheel from slipping or
sliding).

It’s important to note that, at least in the built-in plugins, the forces produced are
proportional to the mass of the wheels. This means that if the body of a vehicle-like
object is much more massive than the wheels, the wheels will have little effect on the
object. This can be compensated for by allowing the user to tune the density of wheels
so that their mass can be tweaked and made closer to the mass of what they are moving.
\begin{quote}

\sphinxstylestrong{Fixed Wheel Plugin}

The fixed wheel plugin emulates a single wheel which cannot rotate to face a
different direction. The wheel may be driven, which means its target angular
velocity can be set and it will produce force in an attempt to travel the
correct linear velocity. The wheel will always produce forces to negate any
movement parallel to its axle (or where the axle would be if one existed).
A list of the properties exposed by the plugin can be see in in Table below


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Property Name
&\sphinxstyletheadfamily 
Data Type
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/input\_speed
&
String
&
The ROS topic to listen on for target angular velocity
\\
\hline
wheel\_radius
&
Double
&
Radius of the wheel in meters
\\
\hline
wheel\_width
&
Double
&
Width of the wheel in meters
\\
\hline
is\_driven
&
Bool
&
Whether or not the wheel should produce driving force based on the input speed
\\
\hline
density
&
Double
&
Density of the wheel. Can be tuned to give more or less mass of the object better
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

and the input channel specification can be found in Table below


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
ROS Topic
&\sphinxstyletheadfamily 
Message Type
&\sphinxstyletheadfamily 
In/Out
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/input\_channel
&
std\_msgs::msg::Float32
&
In
&
\makecell{Target angular velocity (rad/s) to simulate.\\ This information is ignored if \\{[}is\_drive{]} is false.}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Ackermann Steering Plugin}

The Ackermann steering plugin produces two linked wheels which can be steered
together and will follow the Ackermann constraint. The wheels cannot be driven,
they only produce forces to negate horizontal sliding, which can be used to
steer a vehicle-like object. The Properties exposed and ROS channels used can be
seen in the follow tables


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Property Name
&\sphinxstyletheadfamily 
Data Type
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/input\_angle
&
String
&
The ROS topic to listen on for target steering angle
\\
\hline
wheel\_radius
&
Double
&
Radius of the wheel in meters
\\
\hline
wheel\_width
&
Double
&
Width of the wheel in meters
\\
\hline
axle\_lengh
&
Double
&
Distance between the two wheels (meters)
\\
\hline
vehicle length
&
Double
&
Distance from the front azle of the object to the back axle to be used in the Ackermann constraint (meters)
\\
\hline
density
&
Double
&
Density of wheels. Can be tuned to give wheel more or less mass so it affects the object attached better
\\
\hline
steer\_angle
&
Bool
&
Read Only: the current angle being steered to
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

And the input channels can be found below


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
ROS Topic
&\sphinxstyletheadfamily 
Message Type
&\sphinxstyletheadfamily 
In/Out
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/input\_angle
&
std\_msgs::msg::Float32
&
In
&
Angle to steer towards in radians.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\sphinxstylestrong{Sensor Plugins}

Sensors travel with a world object and collect information about the environment.
This information is usually published to the control code through ROS messages so
that the control code can react to what is happening. Sensors plugins should produce
the same messages as their hardware counterparts so that any control code listening to
the messages does not behave differently when the messages are produced by hardware.
\begin{quote}

\sphinxstylestrong{Touch Sensor Ring}

The touch sensor ring plugin mimics a ring of touch sensors with a specific
radius. It is intended to be used on circular robots, so that its radius can
be set to the same as the robot. The sensor ring can be set to sense a specific
section of the circle, and the number of sensors used can be specified. Whenever
the state of one of the buttons changes, a ROS message is published. Extra
circles are drawn on the world visualization to show which touch sensors are
triggered. Details of the properties exposed by the plugin and the ROS messages
it utilizes can be found in the tables below.

The first table is the properties


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Property Name
&\sphinxstyletheadfamily 
Data Type
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/ouput\_channel
&
String
&
ROS topic to output sensor messages
\\
\hline
angle\_start
&
Double (0-360)
&
Angle that the sensed section starts at
\\
\hline
angle\_end
&
Double (0-360)
&
Angle that the sensed section ends at
\\
\hline
ring\_radius
&
Double
&
Radius of the touch sensor ring
\\
\hline
sensor\_count
&
Integer
&
Number of sensor spaced evenly in the slice of the circle defined by angle\_start and angle\_end
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following table shows ROS output messages


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
ROS Topic
&\sphinxstyletheadfamily 
Message Type
&\sphinxstyletheadfamily 
In/Out
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/output\_channel
&
sensor\_msgs::msg::ByteMultiArray
&
Out
&
\makecell{1D vector with one element for\\ each touch sensor on the ring.\\ Untriggered buttons are set\\ to 0, triggered ones are non-0.}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Design Details
\begin{enumerate}
\item {} 
All the required circle shapes for the touch sensors are generated at the start. They are added to and removed from the model when they become active or inactive.

\item {} 
The touch sensor circle is a solid physics shape which can collide. This generates collision points from Box2D that can be used to know what is sensed.

\item {} 
The body with the sensor ring fixture is held in place relative to the robot by a Box2D Weld Joint. The ring has a very low density (so as not to affect how the robot drives) so, due to the implementation of Weld Joints,  it is possible for the ring to behave in strange ways if it is larger than the robot it surrounds. Specifically, if there is a collsion and the robot continues to drive, the robot can be seen moving around within the touch sensor ring; it does not stay anchored in the center as one might expect.

\end{enumerate}

\sphinxstylestrong{Lidar Sensor}

The lidar sensor behaves as a regular hardware lidar would. It scans an area in
front of (or around) itself at a high rate and reports the distances to the
objects scanned. The lidar provided by this plugin can be customized to scan any
size range from 0 to 360 degrees, with the center of the range directly in front
of the lidar. The number of scan rays and the radius (maximum range) can also be
specified, along with the rate of scanning. Each time a scan is performed, the
image representing the lidar and its scan will be updated, and a ROS message
will be published.

Properties of Lidar Sensors


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Property Name
&\sphinxstyletheadfamily 
Data Type
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/ouput\_channel
&
String
&
ROS topic to output sensor messages
\\
\hline
scan\_range
&
Double (0-360)
&
Total angle range to sense, in degrees
\\
\hline
scan radius
&
Double
&
Max distance away from the sensor to detect
\\
\hline
scan\_points
&
Integer \textgreater{}= 2
&
Number of beams spaced evently in the range. Including the first and last beam.
\\
\hline
scan\_rate
&
Double
&
Rate (hz) of scans and messages
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The following table shows ROS output messages


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
ROS Topic
&\sphinxstyletheadfamily 
Message Type
&\sphinxstyletheadfamily 
In/Out
&\sphinxstyletheadfamily 
Description
\\
\hline
channels/output\_channel
&
sensor\_msgs::msg::LaserScan
&
Out
&
\makecell{The standard ROS LaserScan\\ message with parameters filled\\ according to the property settings\\ of the sensor.}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{description}
\item[{Design Details}] \leavevmode\begin{enumerate}
\item {} 
The Box2D shapes used to represent the lidar beams are created any time a Property changes which affects them. During runtime, their lengths are modified to represent what is seen.

\item {} 
Given a range of x degrees, the lidar will report beams from the angle of -x/2 to x/2, relative to the lidar body.

\item {} 
Any beams which do not detect an obstacle will report a distance of infinity, as defined by the implementation of std::numeric\_limits\textless{}float32\textgreater{}::infinity().

\end{enumerate}

\end{description}


\end{quote}

\sphinxstylestrong{Image Loading Plugin}

One of the functions of the original STDR was that it could load an image, and then the dark pixels of the image would be treated as obstacles. This was
simple for the STDR to do because of the way it did collision detection - on a per-pixel basis. Collisions in this project are done in the Box2D engine,
so in order to provide a similar functionality, a plugin is included which converts an image to a set of obstacles which can be loaded into the physics engine.
The plugin can handle the common image formats .png, .jpg, and .bmp. All images are converted to black and white before processing. A threshold is chosen by the
user, and all pixels with an intensity above that are changed to 255 and all pixels with intensity at or below it are set to 0. When a file is loaded, the user is
presented with a prompt in which they can specify the following:

{\color{red}\bfseries{}*}Width and height of the image (meters)
{\color{red}\bfseries{}*}Pixels per meter in both the horizontal and vertical directions
{\color{red}\bfseries{}*}Straightness value for the shapes read
{\color{red}\bfseries{}*}Greyscale threshold

Design Details
\begin{enumerate}
\item {} 
The triangulation and simplification necessary to load polygons into the physics engine is not done in the plugin, but in the polygon component type. Similarly, scaling is also done in the polygon component type.

\end{enumerate}

\sphinxstylestrong{JSON Plugin}

One general-purpose file handler plugin is provided as part of the project. It is able format WorldObjects and WorldObjectComponents as JSON objects which can be
stored in files. The JSON formatter can be used to save single World Objects and entire Simulations

\sphinxstylestrong{Custom Plugins}

Custom plugins should be ROS packages in the same workspace as the simulator package. The plugin’s package.xml file should specify at least the following in order
to resolve build order.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{depend}\PYG{o}{\PYGZgt{}}\PYG{n}{sdsmt\PYGZus{}simulator}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{depend}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{depend}\PYG{o}{\PYGZgt{}}\PYG{n}{sdsmt\PYGZus{}simulator\PYGZus{}box2d}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{depend}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Once Ament is aware of package dependencies, the CMakeLists file must be set up to find the required libraries and files and build the plugin correctly.

First, there are a number of definitions and values that need to be set in order to compile and link the Qt-Specific portions of the plugin

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
find\PYGZus{}package(Qt5 REQUIRED COMPONENTS
Core Gui
)

set(CMAKE\PYGZus{}INCLUDE\PYGZus{}CURRENT\PYGZus{}DIR ON)
set(CMAKE\PYGZus{}AUTOMOC ON)

add\PYGZus{}definitions(\PYGZhy{}DQT\PYGZus{}PLUGIN)
add\PYGZus{}definitions(\PYGZhy{}DQT\PYGZus{}SHARED)

include\PYGZus{}directories( \PYGZdl{}\PYGZob{}CMAKE\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{} )
\end{sphinxVerbatim}

In order to resolve dependencies for Box2D and the header files from the simulator, find\_package needs to be called for the associated packages. Then lstinline\textbar{}include\_directories\textbar{} needs to be called so the Qt MOC can resolve headers

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
find\PYGZus{}package(sdsmt\PYGZus{}simulator REQUIRED)
find\PYGZus{}package(sdsmt\PYGZus{}simulator\PYGZus{}box2d REQUIRED)

ament\PYGZus{}export\PYGZus{}dependencies(
        sdsmt\PYGZus{}simulator
        sdsmt\PYGZus{}simulator\PYGZus{}box2d
)

include\PYGZus{}directories(\PYGZdl{}\PYGZob{}sdsmt\PYGZus{}simulator\PYGZus{}api\PYGZus{}INCLUDE\PYGZus{}DIRS\PYGZcb{})
include\PYGZus{}directories(\PYGZdl{}\PYGZob{}sdsmt\PYGZus{}simulator\PYGZus{}box2d\PYGZus{}INCLUDE\PYGZus{}DIRS\PYGZcb{})
\end{sphinxVerbatim}

Next, any headers in the plugin containing the Q\_OBJECT or other Q\_* macros need to be preprocessed by the MOC

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
set(plugin\PYGZus{}moc\PYGZus{}hdrs a.h b.h ... z.h)
qt5\PYGZus{}wrap\PYGZus{}cpp(MOC\PYGZus{}SRCS \PYGZdl{}\PYGZob{}plugin\PYGZus{}moc\PYGZus{}hdrs\PYGZcb{})
\end{sphinxVerbatim}

Finally, the plugin needs to be built as a shared library and linked against Qt Core libraries and the Box2D library.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
add\PYGZus{}compile\PYGZus{}options(\PYGZhy{}fPIC)

add\PYGZus{}library([plugin name] SHARED \PYGZdl{}\PYGZob{}CPP\PYGZus{}SRCS\PYGZcb{} \PYGZdl{}\PYGZob{}MOC\PYGZus{}SRCS\PYGZcb{})
qt5\PYGZus{}use\PYGZus{}modules([plugin name] Core Gui)

ament\PYGZus{}target\PYGZus{}dependencies([plugin name]
\PYGZdq{}sdsmt\PYGZus{}simulator\PYGZus{}box2d\PYGZdq{}
\PYGZdq{}sdsmt\PYGZus{}simulator\PYGZus{}api\PYGZdq{}
)
\end{sphinxVerbatim}

The last detail is that the plugin must be deployed in the directory above the simulator executable. This can be achieved by installing the plugin to
the lib directory of the workspace install

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{install}\PYG{p}{(}
        \PYG{n}{TARGETS} \PYG{p}{[}\PYG{n}{plugin} \PYG{n}{name}\PYG{p}{]}
        \PYG{n}{DESTINATION} \PYG{n}{lib}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{A Note on ROS Communications}

It is believed by the project team that, because the rclcpp::spin() method may be called from a thread other than the main one, all ROS message callbacks may be run
from a non-main thread. Care should be taken when defining callbacks in components to prevent race conditions which would result from this design. This issue was
resolved in the Touch Sensor Ring plugin with the use of a Qt Signal and Slot. When a Qt Signal triggers a Slot of an object which resides in a different thread,
the slot is queued for the second thread to receive naturally during its event loop, preventing any race conditions. The Touch Sensor Ring component has an internal
signal and slot specifically for this purpose; the signal is emitted by the ROS callback function, and that copies the data from the callback into the main thread
where it can be processed safely.

\end{document}