% !TEX root = DesignDocument.tex

\chapter{User Stories,  Requirements, and Product Backlog}
\section{Overview}
The software will provide methods by which a user can build, simulate, and control robots. The software should be able to import image files and convert them to obstacles which robots can collide with and sense during simulations.

\section{User Stories}
\subsection{User Story \#1}
Client wants to have a 2D simulator for robots designed using ROS.

\subsubsection*{Details}
This user story encapsulates the entire project. The end goal is to provide software which simulates mobile robots on a plane. Additionally, it should be possible for a separate application to control the simulated robots via messages sent by ROS.

\subsection{User Story \#2} 
Client wants to be able to easily swap control channels between the simulator and an actual robot

\subsubsection*{Details}
After the client has simulated a robot and written control code to drive it, they want to be able to unhook the simulator and hook up a real robot. This process should involve minimal changes in the actual control code; the main change should be the ROS channels used for communication of data to and from the control code.

\subsection{User Story \#3} 
Client wants to be able to design a robot with some shape for it's body, a drive system, and any number of sensors

\subsubsection*{Details}
There are many different kinds of mobile robots; the client would like to be able model most of them using this software.

\subsection{User Story \#4} 
Client wants to be able to send joystick messages to the control code from the simulator UI

\subsubsection*{Details}
It is possible to have a separate application which accepts keyboard or mouse input and conveys it to control code as joystick input, but the client would like that functionality as part of the simulator software.

\subsection{User Story \#5}
Client wants to be able to choose what drive system is used (ackermann, differential, mecanum...) and where it is positioned under the robot

\subsubsection*{Details}
See user story \#3. In addition to choosing between drive systems, the client wants to be able to mount them somewhere on the robot other than directly in the center.

\subsection{User Story \#6} 
Client wants to be able to choose what sensors are used (lidar, sonar, touch...) and where they are positioned on top of the robot

\subsubsection*{Details}
See user story \#3. In addition to choosing sensor equipment on the robot, the client would like to be able to position the equipment.

\subsection{User Story \#7} 
Client wants to be able to see a visualization of what sensors detect (when applicable)

\subsection{User Story \#8} 
Client wants the system unit tested

\subsubsection*{Details}
The original software (STDR) was not tested other than through use. The client would like this software to be at least partially tested by a set of functions.

\subsection{User Story \#9} 
Client wants to be able to import an image as the map to drive on

\subsubsection*{Details}
Images should be black and white pixel-maps. The user will select an image and specify it's dimensions in meters as well as an origin location. This data will be used to scale objects in the image to a world-space plane.

\subsection{User Story \#10} 
Client wants to be able to simulate multiple robots at the same time

\subsection{User Story \#11} 
Client wants the robot file format to be compatible with Gazebo 3D simulator

\subsubsection*{Details}
If possible, it would be useful to be able to import and export robot files compatible with the Gazebo 3D simulator; however, it is recognized that this may not be possible due to the complexity of Gazebo simulations.

\subsection{User Story \#12} 
Client wants the software to be easy to modify for use outside of ROS

\subsubsection*{Details}
In the future, the client may want to simulate robots in a setting which cannot make use of the ROS software. In this case, the client would like the simulation to be designed in such a way that the ROS-specific portions can be easily removed and/or replaced.

\section{Requirements and Design Constraints}
\subsection{System  Requirements}
Software will run as a collection of nodes in ROS Kinetic. This means that it must follow ROS package conventions and be compiled through catkin build system on Ubuntu 16.04.

\subsection{Project  Management Methodology}
The project will be managed using an Agile methodology very close to the Scrum Framework. Due to the fact that all members of the team are full-time college students, there will only be group meetings twice a week, and at least one of them will be at a time that the Client can attend. Sprints will be two weeks long, beginning and ending on Thursday.

The project will reside in a private GitHub repository; this repo will contain both the project source code and documentation files.

The backlog will be maintained via a Trello board. All tickets will start in the ``Todo: Future" category and will be moved into the ``Todo: Current Sprint" category at the start of the sprint during which they are to be completed. Tickets in progress should be moved to the ``In Progress" category, and completed work should be moved to the ``Code Review" category. Code will be reviewed during weekly meetings, without the client. After the code associated with a ticket is reviewed and approved, the ticket will be moved to the ``Done" category.

Because the schedules of all team members are highly volatile, the team did not feel that traditional sprint analytics (burndown charts, velocity measurements, and story point counts) would be effective measurements of success. The project will be kept on track using an overall timeline of project milestones, and backlog work will be shuffled between team members during sprints based upon availability.

\section{Product Backlog}
 
\begin{itemize}
\item Current Sprint 
\begin{enumerate}
\item Deployment and Testing Documentation
\item Create Unit Tests
\end{enumerate}
\item Future To-Do 
\begin{enumerate}
\item Use Gazebo file format
\end{enumerate}
\item Done
\begin{enumerate}
\item Built-in Robot Controls 
\item Allow User to Position Wheels
\item Allow Positioning of Sensors on Robot
\item Allow different Robot Shapes
\item Create the Robot Designer
\item Be able to Load Map from Image
\item Prototype Joystick User Interface
\item Doxygen
\item Lidar Sensor Plugin
\item Beacon Sensor Plugin
\item Encoder Sensor Plugin
\item Everyone make Wireframes
\item Allow User to Select World Map JSON file to Load
\item Example Physics Engine Project
\item Example OpenGL Window
\item Contract
\item UI Prototype
\item Create GUI Main Window
\item Solidify Physics Engine to Interface
\item Design Interfaces
\item Write Shape Objects for Passing between Threads
\item Explore Options for Touch Sensors
\item Display/Allow for Robot Sensor Configuration during Simulation
\item Solidify Interface to User Interface
\item Display Objects on World View
\item Decide between Physics Engine and Kinematics
\item Get Catkin working with QTWidgets
\item Allow for Selection of Robots in UI
\item Allow User to Choose from Multiple Drive Systems
\end{enumerate}
\end{itemize}

\section{Research or Proof of Concept Results}
\subsection{Initial Research}
Samuel Williams and Ryley Sutton researched various 2D physics simulation libraries as well as the possibility of writing one from scratch. They advised the team to use the open-source physics engine ``Box2D"

\subsection{Proof of Concept}
Andrew Stelter constructed a number of projects utilizing ROS alongside various Qt applications. The goal of these projects was to find any issues the catkin build system might have with Qt, and determine the best way to build a project using both of these libraries, which require separate event loops. He advised the team to use Qt 5.5, as it is part of the default Ubuntu 16.04 distribution, and to use Qt Widgets for the UI instead of QML because he was unable to find a way to successfully build and run QML applications on a fresh Ubuntu system with out installing Qt separate from ROS.
